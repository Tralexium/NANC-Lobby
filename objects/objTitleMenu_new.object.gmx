<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize vars

//Important vars
sprite_index = -1; // Make the sprite invincible without affecting the draw events
image_speed = .2; // Used for the kid's walking animation;
timer = 0; // Timer var, increments by 1 each frame
select = 1; // Which option is currently selected
confirmSfxTest = false; // If the user has pressed the confirm button during the sound test
canSelect = false; // If the player can select an option
selected = false; // If the player has selected an option
canContinue = false; // If the player can continue a save file
volumeCheck = true; // Player checks if the volume is too loud before entering the menu
volTimer = 0; // Timer specifecaly for volume check
scrollSpd = -2; // How fast everything scrolls
cloudTimer = 0; // Spawns new clouds
cloudNum = 0; // Keeps track the ammount of clouds
nightMode = false // Switches from day and night

//Positions for all draw elements
sfxTestBGX = 0; // Scrolling BG for the sound test screen
sfxTestBGY = 0;
titlePosX = 400; // Initial title x Pos
titlePosY = 304; // Initial title y Pos
selectableX = 400; // Selectable X position
selectableY = 340; // Selectable Y position
arrowPosX = selectableX; // Select arrow x Pos
arrowPosY = selectableY; // Select arrow y Pos
hillX = 0; // The hills behind the floor
hillY = 318;
fgHillX = 0; // The hill behind the hills
fgHillY = 0;
bgX = -20; // The sunset bg x pos
groundX = 0; // Ground x pos
groundY = 0; // Ground y pos
kidX = -50; // That guy that you play with
kidOldX = kidX; // Previous position before starting to move
kidTargetX = 400; // Where the kid should walk to
kidStep = 0; // Timer that interpolates the movement from oldX to newX
kidWalkTime = 80; // How fast the kid aproaches that new position
kidY = room_height+groundY+12;

//Other drawbles for UI
volCheckGlowIconDistance = 0; // Distance between the glowing volume icons
volCheckWhiteGlowSize = 0; // The white sliding light after volume test
selectableScaleNG = 1; // New Game Box
selectableScaleOpt = .7; // Options Box
selectableScaleExit = .7; // Exit Game Box
moonX = 450; // X &amp; Y positions
moonY = 250; // This one should go up and down

//Alpha elements
volCheckAlpha = 0; // Volume check related stuff
volCheckIconAlpha = 0; // Volume Icon in the middle
volCheckGlowIconAlpha = 0; // Glowing volume icons
addIconGlowAlpha = 1; // Adds alpha to the glowing vol icon and each time it goes dimmer
titleAlpha = 0; // Title alpha
selectableAlpha = 0; // The options that you can pick in the menu
arrowAlpha = 0; // Select arrow alpha
dayAlpha = 1; // How opaque the sunset scenery is
if(!volumeCheck)fadeAlpha = 0; // How opaque the fading effect is
else fadeAlpha = 1;

//Scale elements
arrowScale = 1; // The size of the select arrow
titleScale = 1; // Size of the title logo

//Colors
textColor = c_white; // Text color
lineColor = make_colour_rgb(30, 170, 220); // Text Outline color
textShadowColor = lineColor; // Shadow color of the text
fadeColor = 0; // 0: Black, 1: White

// Spawn Clouds
for(i=1; i&lt;=8; i++)
{
  var dist = room_width/8;
  var cloud = instance_create(x+(dist*i),y,objAlexTitleCloud);
      cloud.hspeed = scrollSpd/2 + random(-1);
      cloud.y = irandom(40)*3;
  
  if(i mod 4 != 0)
  {
    cloud.sprite_index = sprAlexBGBackClouds;
    cloud.hspeed = scrollSpd/3 + random(-1);
    cloud.depth = -9;
    cloud.y = irandom_range(30, 80)*3;
  }
}

lineSize = 3; // Text outline size
lineDist = 0; // Line distance between text
for(i = 0; i &lt; 4; i++){ // We do this so that we can get the text width from the selectables
  switch(i){
    case 0:
      selectString[i] = "New Game";
      break;
      
    case 1:
      selectString[i] = "Continue";
      break;
      
    case 2:
      selectString[i] = "Options";
      break;
      
    case 3:
      selectString[i] = "Exit Game";
      break;
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sfx test passed

volumeCheck = false;
fadeColor = 1;
scrPlayMusic(musTitlescreen, true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(volumeCheck){
  if(volTimer == 0){
    audio_play_sound(sndTestSound, 0, true);
  }
  
  volTimer++;
  timer = -30; // Additional delay before we transtion to title
  
  if (!confirmSfxTest &amp;&amp; (scrButtonCheckPressed(global.menuAcceptButton) || keyboard_check_pressed(vk_anykey))){
    alarm[0] = 50;
    audio_play_sound(sndConfirmSoundTest, 0, false);
    audio_stop_sound(sndTestSound)
    confirmSfxTest = true;
  }
  
  if(!confirmSfxTest) 
  {
    volCheckAlpha += .05;
    if(volTimer &gt;= 50)volCheckIconAlpha += .05;
    
    if(volTimer mod 25 == 0 &amp;&amp; volTimer &gt;= 100)
    {
      if(addIconGlowAlpha == 1)volCheckGlowIconDistance = 0;  
      volCheckGlowIconAlpha += addIconGlowAlpha;
      addIconGlowAlpha -= .25;
      if(addIconGlowAlpha &lt;= 0)addIconGlowAlpha = 1;
    }
  }
  else 
  {
    volCheckAlpha -= .05;
    volCheckIconAlpha -= .05;
  }
  
  sfxTestBGX += .5;
  volCheckGlowIconAlpha = lerp(volCheckGlowIconAlpha, 0, .15);
  volCheckGlowIconDistance = lerp(volCheckGlowIconDistance, 300, .03);
  volCheckAlpha = clamp(volCheckAlpha, 0, 1);
  volCheckIconAlpha = clamp(volCheckIconAlpha, 0, 1);
  volCheckGlowIconAlpha = clamp(volCheckGlowIconAlpha, 0, 1);
  
} else {
  timer++;
  if(!selected){ fadeAlpha -= .02; }
}

// Initialize the intro sequence
if(timer &gt;= 0 &amp;&amp; timer &lt; 50){
  titleAlpha += .02;
}
else if(timer &gt;= 50 &amp;&amp; timer &lt; 100){
  titlePosY = lerp(titlePosY, 100, .04);
  titleScale = lerp(titleScale, .8, .04);
}
else if(timer &gt;= 100 &amp;&amp; timer &lt;= 150){
  selectableY = lerp(selectableY, 326, .05);
  selectableAlpha += .02;
  
  //Enable selecting an option
  if(timer == 150)
  {
    canSelect = true;
    fadeColor = 0;
  }
}

if(canSelect){

    // Check for key presses
    if(scrButtonCheckPressed(global.menuRightButton)){
        select++;
        kidStep = 0;
        kidOldX = kidX;
        kidWalkTime = 40;
        audio_play_sound(sndSelectArrow, 0, false);
        if(select &gt; 2)select = 0;
    }else if(scrButtonCheckPressed(global.menuLeftButton)){
        select--;
        kidStep = 0;
        kidOldX = kidX;
        kidWalkTime = 40;
        audio_play_sound(sndSelectArrow, 0, false);
        if(select &lt; 0)select = 2;
    }
    
    //Check for confirmation
  if (scrButtonCheckPressed(global.menuAcceptButton) || keyboard_check_pressed(vk_enter)){
        canSelect = false;
        selected = true;
        timer = 1000;
        kidStep = 0;
        kidOldX = kidX;
        audio_play_sound(sndSelectMainMenu, 0, false);
        
        // Fade out the music with different lengths based on the selected option
        switch(select){
            case 1: // Select Save File

                break;
            
            case 2: // Exit game
                kidTargetX = kidX + 500;
                kidWalkTime = 100;
                audio_sound_gain(global.currentMusicID, 0, 2000);
                break;             
        }
    }
    
    // Arrow related draw vars
    if(arrowAlpha &lt; 1){arrowAlpha += .05;}
    var posX = selectableX - (string_width(selectString[select])/1.5) - 60;
    arrowPosX = posX + (-1 * abs(dsin(timer*4)*10));
    arrowPosY = lerp(arrowPosY, selectableY+(select*lineDist), .2);
    
    //When coming back from a different menu increase the alpha of title and selectables
    if(titleAlpha &lt; 1){titleAlpha += .05;}
    if(selectableAlpha &lt; 1){selectableAlpha += .05}
}

if(selected){
    // Vanish the arrow
    if(arrowScale &gt; 0)arrowScale -= .1;
    
    // Fade out elements based on the selected option
    if(timer &gt;= 1020){
        if(select == 0 || select == 1){
            titleAlpha -= .05;
            selectableAlpha -= .05;
        }else{
            titleAlpha -= .025;
            fadeAlpha += .025;
        }
    }
    
    if(fadeAlpha &gt;= 1.5 || selectableAlpha &lt;= -0.5)
    {        
        switch(select){
            case 0: // Open Options
                instance_create(0,0, objOptionsMenu);
                selected = false;
                selectableAlpha = 0;
                arrowScale = 1;
                arrowAlpha = 0;
                nightMode = true;
                break;
        
            case 1: // Start a Save File
                instance_create(0,0, objDifficultyMenu);
                selected = false;
                selectableAlpha = 0;
                arrowScale = 1;
                arrowAlpha = 0;
                nightMode = true;
                break;
                /*
                global.gameStarted = true; //sets game in progress (enables saving, restarting, etc.)
                global.autosave = true;
                
                global.difficulty = 0;
                
                if (file_exists("Data\save"+string(global.savenum)))
                    file_delete("Data\save"+string(global.savenum));
                
                room_goto(global.startRoom);
                break;
                */
            
            case 2: // Closes the game
                game_end();
                break;
                
            case 999: // Load existing game
                if (file_exists("Data\save"+string(global.savenum)))
                scrLoadGame(true);
                break;
        }
    }
}

//Clamp specific draw values
// Alphas
titleAlpha = clamp(titleAlpha, 0, 1);
fadeAlpha = clamp(fadeAlpha, 0, 1.5);
selectableAlpha = clamp(selectableAlpha, -0.5, 1);
// Scales
arrowScale = clamp(arrowScale, 0, 1);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Drawing related

// Keep the player position stuck with the ground
kidY = room_height+groundY+12+192;

// Spawn clouds
cloudTimer++;
if(cloudTimer mod 100 == 0)
{
  cloudNum++;
  var dist = room_width/15;
  var cloud = instance_create(x+1250,y,objAlexTitleCloud);
      cloud.hspeed = scrollSpd/2 + random(-1);
      cloud.y = irandom(30)*3;
  
  if(cloudNum mod 4 != 0)
  {
    cloud.sprite_index = sprAlexBGBackClouds;
    cloud.hspeed = scrollSpd/3 + random(-1);
    cloud.depth = -9;
    cloud.y = irandom_range(30, 60)*3;
  }
}

// Selection boxes scalling
var spd = .2;
if(canSelect)
{
  switch(select)
  {
    case 0:
      selectableScaleNG = lerp(selectableScaleNG, .7, spd);
      selectableScaleOpt = lerp(selectableScaleOpt, 1, spd);
      selectableScaleExit = lerp(selectableScaleExit, .7, spd);
      kidTargetX = 400-250;
      break;
      
    case 1:
      selectableScaleNG = lerp(selectableScaleNG, 1, spd);
      selectableScaleOpt = lerp(selectableScaleOpt, .7, spd);
      selectableScaleExit = lerp(selectableScaleExit, .7, spd);
      kidTargetX = 400;
      break;
      
    case 2:
      selectableScaleNG = lerp(selectableScaleNG, .7, spd);
      selectableScaleOpt = lerp(selectableScaleOpt, .7, spd);
      selectableScaleExit = lerp(selectableScaleExit, 1, spd);
      kidTargetX = 400+250;
      break;
  }
}
else
{
  selectableScaleNG = lerp(selectableScaleNG, .7, spd);
  selectableScaleOpt = lerp(selectableScaleOpt, .7, spd);
  selectableScaleExit = lerp(selectableScaleExit, .7, spd);
}

// Kid
if(timer &gt; 100)
{
  // Walking to target
  if(kidStep &lt; kidWalkTime)
  {
    if(kidOldX &lt; kidTargetX){image_speed = .4;}
    else{image_speed = -.4;}
    kidStep++;
    //kidX = scrAlexEaseInOutSine(kidStep, kidOldX, kidTargetX, kidWalkTime);
  }
  else
  {
    image_speed = .2;
  }
  
  if(canSelect)
  {
    groundY = lerp(groundY, -334, .04);
  }
  else{  
    if(select == 0 || select == 1)
    {
      groundY = lerp(groundY, 0, .02);
    }
  }
}

// Front Hills
fgHillX += scrollSpd/1.5;

// Ground
groundX += scrollSpd;
if(timer &gt;= 50 &amp;&amp; timer &lt; 150){groundY = scrAlexEaseOutSine(timer-50, 0, -334, 100);}

// Back Hills
hillX += scrollSpd/3;
if(hillX &lt; -200){hillX = room_width;}

// Sunset BG
bgX += scrollSpd/2;

// Moon
moonY = 250+(sin(timer/18)*16);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Night and Day cycle

if(nightMode)
{
  dayAlpha -= .05;
}
else
{
  dayAlpha += .05;
}

dayAlpha = clamp(dayAlpha, 0, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw any text and fading animations

// Temp vars
var fadeCol = merge_colour(c_black, c_white, fadeColor);

// Version number
draw_set_font(fAlex20);
draw_set_halign(fa_right);
draw_set_valign(fa_middle);
draw_sprite_ext(sprAlexTitleOptionHolder, 0, 900, 588, 1, 0.5, 0, c_white, selectableAlpha - 0.3);
//scrAlexDrawTextShadow("Version: " + string(global.version), 790, 587, 0, 2, textColor, textShadowColor, selectableAlpha, selectableAlpha);
draw_set_alpha(1);

// Draw version checking
draw_set_font(fAlex30);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);
if (global.updateRecommended)
{
    draw_set_alpha(selectableAlpha);
    //scrAlexDrawTextOutlineExtra(400, 550, "New version available!", c_yellow, c_black, 5);
    draw_set_alpha(1);
}

// Get line distance based on selectable font
lineDist = string_height("E")+32;

// Draw the selectables
/*
scrAlexDrawTextShadow("New Game", selectableX, selectableY, 0, 4, textColor, textShadowColor, selectableAlpha, selectableAlpha);
scrAlexDrawTextShadow("Continue", selectableX, selectableY+(lineDist), 0, 4, textColor, textShadowColor, selectableAlpha, selectableAlpha);
scrAlexDrawTextShadow("Options", selectableX, selectableY+(lineDist*2), 0, 4, textColor, textShadowColor, selectableAlpha, selectableAlpha);
scrAlexDrawTextShadow("Exit Game", selectableX, selectableY+(lineDist*3), 0, 4, textColor, textShadowColor, selectableAlpha, selectableAlpha);
draw_sprite_ext(sprSelectArrow, 0, arrowPosX, arrowPosY, 1, arrowScale, 0, -1, arrowAlpha);
*/

// New Game boxes
draw_sprite_ext(sprAlexTitleSelectionBox, 1, selectableX-20, selectableY+20, 1.5*(selectableScaleNG-.5), 1.5*(selectableScaleNG-.5), 0, -1, selectableAlpha);
draw_sprite_ext(sprAlexTitleSelectionBox, 2, selectableX+35, selectableY+25, 1.5*(selectableScaleNG-.5), 1.5*(selectableScaleNG-.5), 0, -1, selectableAlpha);
draw_sprite_ext(sprAlexTitleSelectionBox, 0, selectableX, selectableY, selectableScaleNG, selectableScaleNG, 0, -1, selectableAlpha);
// Options boxes
draw_sprite_ext(sprAlexTitleSelectionBox, 1, selectableX-20-250, selectableY+20, 1.5*(selectableScaleOpt-.5), 1.5*(selectableScaleOpt-.5), 0, -1, selectableAlpha);
draw_sprite_ext(sprAlexTitleSelectionBox, 2, selectableX+35-250, selectableY+25, 1.5*(selectableScaleOpt-.5), 1.5*(selectableScaleOpt-.5), 0, -1, selectableAlpha);
draw_sprite_ext(sprAlexTitleSelectionBox, 0, selectableX-250, selectableY, selectableScaleOpt, selectableScaleOpt, 0, -1, selectableAlpha);
// Exit boxes
draw_sprite_ext(sprAlexTitleSelectionBox, 1, selectableX-20+250, selectableY+20, 1.5*(selectableScaleExit-.5), 1.5*(selectableScaleExit-.5), 0, -1, selectableAlpha);
draw_sprite_ext(sprAlexTitleSelectionBox, 2, selectableX+35+250, selectableY+25, 1.5*(selectableScaleExit-.5), 1.5*(selectableScaleExit-.5), 0, -1, selectableAlpha);
draw_sprite_ext(sprAlexTitleSelectionBox, 0, selectableX+250, selectableY, selectableScaleExit, selectableScaleExit, 0, -1, selectableAlpha);

// Selectable text
//scrAlexDrawTextShadow("Play", selectableX+4, selectableY-(8*selectableScaleNG), 0, 4, textColor, textShadowColor, selectableAlpha, selectableAlpha);
//scrAlexDrawTextShadow("Option", selectableX-250+4, selectableY-(8*selectableScaleOpt), 0, 4, textColor, textShadowColor, selectableAlpha, selectableAlpha);
//scrAlexDrawTextShadow("Exit", selectableX+250+4, selectableY-(8*selectableScaleExit), 0, 4, textColor, textShadowColor, selectableAlpha, selectableAlpha);


// Draw intro text, title and black overlay for fading
draw_sprite_ext(sprAlexTitleScreen, 0, titlePosX, titlePosY, titleScale, titleScale, 0, -1, titleAlpha)
draw_set_alpha(fadeAlpha);
draw_set_colour(fadeCol);
draw_rectangle(-1, -1, 800, 608, false);
draw_set_alpha(1);

// Volume Check

draw_sprite_tiled_ext(sprAlexSoundTestBG, 0, sfxTestBGX, sfxTestBGY, 1, 1, -1, (volCheckAlpha/2)+(volCheckGlowIconAlpha/3))
draw_sprite_ext(sprAlexSoundTestIcon, 0, 400, 304, 1, 1, 0, -1, volCheckIconAlpha);
draw_set_blend_mode(bm_add);
draw_sprite_ext(sprAlexSoundTestIcon, 1, 400+volCheckGlowIconDistance, 304, 1, 1, 0, -1, volCheckGlowIconAlpha);
draw_sprite_ext(sprAlexSoundTestIcon, 1, 400-volCheckGlowIconDistance, 304, 1, 1, 0, -1, volCheckGlowIconAlpha);
draw_sprite_ext(sprAlexSoundTestFMIcon, 0, 740, 608-60, 1, 1, 0, -1, (volCheckAlpha/2)+(volCheckGlowIconAlpha/2));
draw_set_blend_mode(bm_normal);
draw_sprite_ext(sprAlexSoundTestBox, 0, 0, 608, 1, 1, 0, -1, volCheckAlpha);

draw_set_alpha(1);
draw_set_font(fAlex20);
draw_set_halign(fa_left);
draw_set_valign(fa_bottom);
//if(volumeCheck)scrAlexDrawTextShadow("Volume Check: press any key to continue" ,10, 608-16, 0, 3, textColor, textShadowColor, volCheckAlpha, volCheckAlpha);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the scenery

// Sunset BG
draw_sprite_tiled_ext(sprAlexTitleBGSunset, 1, bgX, 0, 3, 3, -1, 1);
draw_sprite_ext(sprAlexTitleMoon, 0, moonX, moonY, 3, 3, 0, -1, 1);
draw_sprite_tiled_ext(sprAlexTitleBGSunset, 0, bgX, 0, 3, 3, -1, dayAlpha);

// Back Hills
draw_sprite_ext(sprAlexTitleBGBackHills, 1, hillX, hillY, 3, 3, 0, -1, 1);
draw_sprite_ext(sprAlexTitleBGBackHills, 0, hillX, hillY, 3, 3, 0, -1, dayAlpha);

// Front Hills
draw_sprite_tiled_ext(sprAlexTitleBGHills, 1, fgHillX, fgHillY, 3, 3, -1, 1);
draw_sprite_tiled_ext(sprAlexTitleBGHills, 0, fgHillX, fgHillY, 3, 3, -1, dayAlpha);

// Ground
draw_sprite_tiled_ext(sprAlexTitleGround, 0, groundX, groundY, 3, 3, -1, 1);

// Kid
draw_sprite_ext(sprPlayerRunning, image_index, kidX, kidY, 4, 4, 0, -1, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
