<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init vars

// Core
timer = 0;
active = false;
close_ui = false;
save_index = 0;
intro_animation_length = 20;
load_game = false; // Whether to start a new game or load the save file
overlay_opacity_trigger = 1.4; // What the opacity needs to be in order to start the gameplay.
default_difficulty = 0;

for(var i=0; i&lt;4; i++) {
    option_index[i] = 0; // Which option is the arrow currently on
    sub_menu_index[i] = 0; // 0: save stats, 1: new/load game, 2: erase file
    goto_sub_menu[i] = -1; // Set this to go to a different sub menu next time contents fade out
    content_alpha[i] = 1;
}

// Visual
draw_alpha = 0;

content_fade_length = 30;
content_fade_timer = -1;

overlay_alpha = 0;
fade_in_overlay = false; // Fades in the dark overlay when we chosen a file
fade_in_overlay_spd = 0.02; // Fading speed for the overlay

header_font = fMenuLobby12;
header_text = "Choose a Save File";
header_x = room_width/2;
header_y = 32;

white_col = $e8e0df; // Greyish white
sky_col = $ceb85a; // Sky blue
pink_col = $702a9c; // Redish fuchsia
yellow_col = $41bbf0; // Golden yellow
dark_col = $2e1814; // Night blue black
red_col = $4d30d5 // Red
gradient_col = sky_col; // Alters between sky blue and pink
gradient_col_clear = yellow_col; // Alters between sky blue and yellow
gradient_spd = 1;

box_anchor_x = room_width/2;
box_anchor_y = room_height/2 + 28;
box_w = 300;
box_h = 170;
box_corner_rad = 60;
box_pad_h = 0;
box_pad_v = 0;
box_pad_h_start = 192-32;
box_pad_v_start = 128-32;
box_pad_h_end = 192;
box_pad_v_end = 128;

selection_box_w = box_w;
selection_box_h = box_h;
selection_box_start_w = selection_box_w;
selection_box_start_h = selection_box_h;
selection_box_end_w = selection_box_w;
selection_box_end_h = selection_box_h + 80;
selection_box_anim_timer = 0;
selection_box_anim_length = 25;

top_bottom_info_pad = 9;
bottom_info_h_pad = 100;
save_file_font = fMenuLobby12;
time_deaths_font = fLobbySmall24;

clears_secrets_x_dist = 120;
clears_secrets_icons_x_dist = 16;
clears_secrets_y_dist = 26;

completion_ring_x_dist = 75;
completion_ring_anim_timer = 0;
completion_ring_anim_length = 30;
box_content_font = fMenuLobby12;

stars_pad = 32;
stars_y_dist = -42;

arrow_wiggle = 0;
arrow_wiggle_amnt = 8;

//load save file values
for (var i = 0; i &lt; 4; i++)
{
    if (file_exists("Data\save"+string(i+1)))  //check if current save exists
    {
        //load save data
        save_exists[i] = true;
        
        //load the save map
        var saveMap;
        
        if (global.extraSaveProtection) //use ds_map_secure function
        {
            saveMap = ds_map_secure_load("Data\save"+string(i+1));
        }
        else    //use text file
        {
            var f = file_text_open_read("Data\save"+string(i+1));
            
            saveMap = ds_map_create();
            ds_map_read(saveMap,base64_decode(file_text_read_string(f)));
            
            file_text_close(f);
        }
        
        save_deaths[i] = ds_map_find_value(saveMap,"death");
        if (is_undefined(save_deaths[i]))
            save_deaths[i] = "///";
        
        save_time_raw[i] = ds_map_find_value(saveMap,"time");
        if (is_undefined(save_time_raw[i])) {
            save_time[i] = "//://://";         
        } else {
            // Convert raw time to a readable format    
            var t = save_time_raw[i];
        
            save_time[i] = string(t div 3600) + ":";
            t = t mod 3600;
            save_time[i] += string(t div 600);
            t = t mod 600;
            save_time[i] += string(t div 60) + ":";
            t = t mod 60;
            save_time[i] += string(t div 10);
            t = t mod 10;
            save_time[i] += string(floor(t));
        }
        
        save_stages_cleared[i] = ds_map_find_value(saveMap,"saveTotalStagesCleared");
        if (is_undefined(save_stages_cleared[i]))
            save_stages_cleared[i] = 0;
            
        save_secrets_found[i] = ds_map_find_value(saveMap,"saveTotalSecretsFound");
        if (is_undefined(save_secrets_found[i]))
            save_secrets_found[i] = 0;
            
        save_stars_found[i] = ds_map_find_value(saveMap,"saveTotalCrystalStarsFound");
        if (is_undefined(save_stars_found[i]))
            save_stars_found[i] = 0;
              
        save_clear[i] = ds_map_find_value(saveMap,"saveGameClear");
        if (is_undefined(save_clear[i]))
            save_clear[i] = false;
        
        ds_map_destroy(saveMap);
        
        
        // Calculate completion percentage
        var _all_tasks = global.totalNumberOfStages + global.secretItemTotal + global.totalNumberOfCrystalStars + 1;  // The one is for clearing the game
        var _finished_tasks = save_stages_cleared[i] + save_secrets_found[i] + save_stars_found[i] + save_clear[i];
        
        save_completion[i] = 0;
        save_completion_target[i] = min(floor((100 / _all_tasks) * _finished_tasks), 100);  // for the cool circle animation
    }
    else
    {
        save_exists[i] = false;
        save_deaths[i] = "///";
        save_stages_cleared[i] = 0;
        save_secrets_found[i] = 0;
        save_stars_found[i] = 0;
        save_time[i] = "//://://";
        save_completion[i] = 0;
        save_completion_target[i] = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Back to main menu

with(objNewTitleMenu){
    can_interact = true;
}
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Logic &amp; Input

timer++;

if(timer == intro_animation_length)
    active = true;
    
if(active) {
    var _H, _V, _Back, _Select;
    _H = scrButtonCheckPressed(global.menuRightButton) - scrButtonCheckPressed(global.menuLeftButton);
    _V = scrButtonCheckPressed(global.menuDownButton) - scrButtonCheckPressed(global.menuUpButton);
    _Back = scrButtonCheckPressed(global.menuBackButton) || keyboard_check_pressed(vk_escape);
    _Select = scrButtonCheckPressed(global.menuAcceptButton) || keyboard_check_pressed(vk_enter);

    if(_Back) {
        active = false;
        audio_play_sound(sndAlexMenuGoBack, 0, false);
    
        if(sub_menu_index[save_index] &gt; 0) {
            goto_sub_menu[save_index] = sub_menu_index[save_index] - 1;
            content_fade_timer = 0;
        } else {
            close_ui = true;
        }
    }
    
    if(_Select) {
        active = false;
        
        switch(sub_menu_index[save_index]) {
            // New game if empty save or goto next sub-menu
            case 0:
                if(save_exists[save_index]) {
                    audio_play_sound(sndAlexMenuConfirm, 0, false);
                    goto_sub_menu[save_index] = 1;
                    content_fade_timer = 0;
                } else {
                    // Start a new game
                    event_user(0);
                }
                break;
            
            // Continue or New game
            case 1:
                if(option_index[save_index] == 0) {
                    // Load game
                    event_user(1);
                } else {
                    audio_play_sound(sndAlexMenuConfirm, 0, false);
                    goto_sub_menu[save_index] = 2;
                    content_fade_timer = 0;
                }
                break;
            
            // Confirm deletion of the save file
            case 2:
                if(option_index[save_index] == 1) {
                    // Start a new game
                    event_user(0);
                } else {
                    audio_play_sound(sndAlexMenuGoBack, 0, false);
                    goto_sub_menu[save_index] = 1;
                    content_fade_timer = 0;
                }
                break;
        }
    }
    
    if(_H + _V != 0) {        
        if(sub_menu_index[save_index] == 0) {
            audio_play_sound(sndAlexMenuSwitchOption, 0, false);
            selection_box_anim_timer = 0;
            
            save_index += _H + (_V * 2);
            if(save_index &gt; 3)
                save_index -= 4;
            if(save_index &lt; 0)
                save_index += 4;
        } else {
            if(_V != 0)
                audio_play_sound(sndAlexMenuSwitchOption, 0, false);
            
            option_index[save_index] += _V;
            if(option_index[save_index] &gt; 1)
                option_index[save_index] -= 2;
            if(option_index[save_index] &lt; 0)
                option_index[save_index] += 2;
        }
    }
}

if(close_ui) {
    draw_alpha -= .05;
    if(draw_alpha &lt;= 0 &amp;&amp; !alarm[0])
        alarm[0] = 20;
}

// New game or load file
if(overlay_alpha &gt;= overlay_opacity_trigger) {
    audio_sound_gain(global.currentMusic, 1, 100);
    global.savenum = save_index+1;
    
    if(load_game) {
        //load existing save file
        if (file_exists("Data\save"+string(global.savenum)))
            scrLoadGame(true);
        else
            show_debug_message("File " + "Data\save"+string(global.savenum) + " no longer exists")
    } else {
        //start new game
        global.gameStarted = true; //sets game in progress (enables saving, restarting, etc.)
        global.autosave = true;
        
        global.difficulty = default_difficulty;
        
        if (file_exists("Data\save"+string(global.savenum)))
            file_delete("Data\save"+string(global.savenum));
        
        room_goto(global.startRoom);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation

// Shift the colors for the gradient
var _amnt = abs(dsin(timer * gradient_spd));
gradient_col = merge_colour(sky_col, pink_col, _amnt);
gradient_col_clear = merge_colour(yellow_col, pink_col, _amnt);

// Intro animation
if(timer &lt;= intro_animation_length) {
    draw_alpha = scrAlexEaseOutSine(timer, 0, 1, intro_animation_length);
    box_pad_h = scrAlexEaseOutSine(timer, box_pad_h_start, box_pad_h_end, intro_animation_length);
    box_pad_v = scrAlexEaseOutSine(timer, box_pad_v_start, box_pad_v_end, intro_animation_length);
} else {
    // Selection box that pops from the top and bottom of each save file
    if(selection_box_anim_timer &lt;= selection_box_anim_length) {
        selection_box_w = scrAlexEaseOutElastic(selection_box_anim_timer, selection_box_start_w, selection_box_end_w, selection_box_anim_length);
        selection_box_h = scrAlexEaseOutElastic(selection_box_anim_timer, selection_box_start_h, selection_box_end_h, selection_box_anim_length);
        selection_box_anim_timer++;
    }
    
    // Completion ring starting animation
    if(completion_ring_anim_timer &lt;= completion_ring_anim_length) {
        for(var i=0; i&lt;4; i++) {
            save_completion[i] = round(scrAlexEaseOutSine(completion_ring_anim_timer, 0, save_completion_target[i], completion_ring_anim_length));
        }
        completion_ring_anim_timer++;
    }
}

// Arrow wiggle
arrow_wiggle = dsin(timer*3) * arrow_wiggle_amnt;

// Content fading
if(content_fade_timer &lt;= 360 &amp;&amp; content_fade_timer != -1) {
    content_fade_timer += 360 / content_fade_length;
    content_alpha[save_index] = dcos(content_fade_timer);
    
    if(content_fade_timer &gt;= 360) {
        content_alpha[save_index] = 1;
        content_fade_timer = -1;
        active = true;
    } else if(content_fade_timer &gt;= 180 &amp;&amp; goto_sub_menu[save_index] != -1) {
        sub_menu_index[save_index] = goto_sub_menu[save_index];
        option_index[save_index] = 0;
        goto_sub_menu[save_index] = -1;
    }
}

// Overlay fading
if(fade_in_overlay) {
    overlay_alpha += fade_in_overlay_spd;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Load the current save file
audio_play_sound(sndAlexVolumeCheckConfirm, 0, false);
audio_sound_gain(global.currentMusic, 0, 1000);
fade_in_overlay = true;
load_game = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Start a new game
audio_play_sound(sndAlexVolumeCheckConfirm, 0, false);
audio_sound_gain(global.currentMusic, 0, 1000);
fade_in_overlay = true;
load_game = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Interface

// Header
draw_set_font(header_font);
scrDrawTextSquareOutline(header_x, header_y, header_text, white_col, dark_col, 2, fa_center, fa_top);

// Draw the save files &amp; info
var _accent_col;
var _box_x1, _box_y1, _box_x2, _box_y2;
var _save_num_x, _save_num_y, _save_num_string;
var _time_x, _time_y;
var _deaths_x, _deaths_y;
var _clears_x, _clears_y, _clears_string;
var _secrets_x, _secrets_y, _secrets_string;
var _clears_icon_x, _clears_icon_y;
var _secrets_icon_x, _secrets_icon_y;
var _ring_x, _ring_y, _ring_val, _ring_string;
var _sub_menu_header_x, _sub_menu_header_y;
var _sub_menu_opt_x, _sub_menu_opt_y, _sub_menu_opt_v_sep;
var _arrow_x_1, _arrow_x_2, _arrow_y;
var _star_x, _star_y, _star_amnt;

var _i = 0;

for(var yy=-1; yy&lt;=1; yy += 2) {
    for(var xx=-1; xx&lt;=1; xx += 2) {  
        
        draw_set_alpha(draw_alpha);
        
        // Choose accent color based if the file is 100%
        if(save_completion_target[_i] == 100) {
            _accent_col = gradient_col_clear;
        } else {
            _accent_col = gradient_col;
        }
    
        // Gradient Box
        if(_i == save_index &amp;&amp; timer &gt; intro_animation_length) {
            _box_x1 = box_anchor_x + (((selection_box_w / 2) + box_pad_h) * xx);
            _box_x2 = box_anchor_x + ((-(selection_box_w / 2) + box_pad_h) * xx);
            
            if(_i &lt;= 1) {
                _box_y1 = box_anchor_y + (((selection_box_h / 2) + box_pad_v) * yy);
                _box_y2 = box_anchor_y + ((-(selection_box_h / 2) + box_pad_v) * yy);
            } else {
                _box_y2 = box_anchor_y + (((selection_box_h / 2) + box_pad_v) * yy);
                _box_y1 = box_anchor_y + ((-(selection_box_h / 2) + box_pad_v) * yy);
            }
            
            draw_set_colour(_accent_col);
            draw_roundrect_ext(_box_x1, _box_y1, _box_x2, _box_y2, box_corner_rad, box_corner_rad, false);
        
            // Save number, time &amp; deaths
            var _fix_text_y = 4;
            
            _save_num_x = box_anchor_x + (box_pad_h * xx);
            _save_num_y = _box_y1 + top_bottom_info_pad;
            _save_num_string = "Save " + string(_i + 1);
            draw_set_font(save_file_font);
            scrDrawTextSquareOutline(_save_num_x, _save_num_y, _save_num_string, white_col, dark_col, 2, fa_center, fa_top);
            
            _time_x = box_anchor_x + (box_pad_h * xx) - bottom_info_h_pad;
            _time_y = _box_y2 - top_bottom_info_pad;
            draw_set_font(time_deaths_font);
            scrDrawTextSquareOutline(_time_x, _time_y + _fix_text_y, save_time[_i], white_col, dark_col, 2, fa_left, fa_bottom);
            draw_sprite(sprAlexMenuSaveTimeDeathIcons, 0, _time_x - 8, _time_y);
            
            _deaths_x = box_anchor_x + (box_pad_h * xx) + bottom_info_h_pad + 30;
            _deaths_y = _box_y2 - top_bottom_info_pad;
            draw_set_font(time_deaths_font);
            var _deaths_string_w = string_width(save_deaths[_i]);
            scrDrawTextSquareOutline(_deaths_x, _deaths_y + _fix_text_y, save_deaths[_i], white_col, dark_col, 2, fa_right, fa_bottom);
            draw_sprite(sprAlexMenuSaveTimeDeathIcons, 1, _deaths_x - 8 - _deaths_string_w, _deaths_y);
        }
        
        // Dark box
        _box_x1 = box_anchor_x + (((box_w / 2) + box_pad_h) * xx);
        _box_x2 = box_anchor_x + ((-(box_w / 2) + box_pad_h) * xx);
        _box_y1 = box_anchor_y + (((box_h / 2) + box_pad_v) * yy);
        _box_y2 = box_anchor_y + ((-(box_h / 2) + box_pad_v) * yy);
        
        draw_set_colour(dark_col);
        draw_roundrect_ext(_box_x1, _box_y1, _box_x2, _box_y2, box_corner_rad, box_corner_rad, false);        
        
        
        // Save file contents
        var _x_center = box_anchor_x + (box_pad_h * xx);
        var _y_center = box_anchor_y + (box_pad_v * yy);
        var _fix_text_y = 4;
        var _space_for_stars = 24 * sign(save_stars_found[_i]);
        draw_set_alpha(draw_alpha * content_alpha[_i]);
        
        switch(sub_menu_index[_i]) {
            case 0:                
                draw_set_colour(_accent_col);
                if(save_exists[_i]) {
                    // Clears
                    draw_set_font(box_content_font)
                    draw_set_halign(fa_right);
                    draw_set_valign(fa_middle);
                    
                    _clears_x = _x_center + clears_secrets_x_dist;
                    _clears_y = _y_center - clears_secrets_y_dist + _space_for_stars + _fix_text_y*2;
                    _clears_string = string(save_stages_cleared[_i]) + "/" + string(global.totalNumberOfStages);
                    draw_text(_clears_x, _clears_y, _clears_string);
                    _clears_icon_x = _x_center + clears_secrets_icons_x_dist + 4;
                    _clears_icon_y = _y_center - clears_secrets_y_dist + _space_for_stars;
                    draw_sprite_ext(sprAlexMenuClearCheckmark, 0, _clears_icon_x, _clears_icon_y, 1, 1, 0, _accent_col, draw_alpha * content_alpha[_i]);
                     
                    // Secrets
                    _secrets_x = _x_center + clears_secrets_x_dist;
                    _secrets_y = _y_center + clears_secrets_y_dist + _space_for_stars + _fix_text_y;
                    _secrets_string = string(save_secrets_found[_i]) + "/" + string(global.secretItemTotal);
                    draw_text(_secrets_x, _secrets_y, _secrets_string);
                    _secrets_icon_x = _x_center + clears_secrets_icons_x_dist;
                    _secrets_icon_y = _y_center + clears_secrets_y_dist + _space_for_stars;
                    draw_sprite_ext(sprAlexMenuSecretIcon, 0, _secrets_icon_x, _secrets_icon_y, 1, 1, 0, _accent_col, draw_alpha * content_alpha[_i]);
                    
                    // Completion ring
                    _ring_x = _x_center - completion_ring_x_dist;
                    _ring_y = _y_center + _space_for_stars;
                    _ring_val = save_completion[_i] / 100;
                    draw_sprite_ext(sprAlexMenuSaveCompletionRing, 0, _ring_x, _ring_y, 1, 1, 0, _accent_col, draw_alpha/3 * content_alpha[_i]);
                    var _ring_tex = sprite_get_texture(sprAlexMenuSaveCompletionRing, 0);
                    scrAlexDrawPieTexExt(_ring_x, _ring_y, _ring_val, _ring_tex, sprAlexMenuSaveCompletionRing, 0, _accent_col, draw_alpha * content_alpha[_i]);
                    _ring_string = string(save_completion[_i]) + "%";
                    scrDrawTextSquareOutline(_ring_x + 2, _ring_y + _fix_text_y + 2, _ring_string, _accent_col, dark_col, 2, fa_center, fa_middle);
                    
                    // Stars &amp; Crown
                    _star_amnt = save_stars_found[_i];
                    _star_x = _x_center - ((_star_amnt-1)*stars_pad)/2;
                    _star_y = _y_center + stars_y_dist;
                    if(!save_clear[_i]) {
                        var _current_star_x = _star_x;
                        for(var i=0; i&lt;_star_amnt; i++) {
                            draw_sprite_ext(sprAlexMenuSaveStar, 0, _current_star_x, _star_y, 1, 1, 0, _accent_col, draw_alpha * content_alpha[_i]);
                            _current_star_x += stars_pad;
                        }
                    } else {
                        draw_sprite_ext(sprAlexMenuSaveCrown, 0, _x_center, _star_y, 1, 1, 0, _accent_col, draw_alpha * content_alpha[_i]);
                    }
                    
                } else {
                    draw_set_font(fMenuLobby18);
                    draw_set_halign(fa_center);
                    draw_set_valign(fa_middle);
                    draw_text(_x_center + 4, _y_center + _fix_text_y*2, "EMPTY");
                }
                break;
            
            case 1:
            case 2:
                _sub_menu_header_x = _x_center;
                _sub_menu_header_y = _y_center - 50;
                _sub_menu_opt_x = _x_center;
                _sub_menu_opt_y = _y_center + 10;
                _sub_menu_opt_v_sep = 36;
                _arrow_x_1 = _x_center - 96 - arrow_wiggle;
                _arrow_x_2 = _x_center + 96 + arrow_wiggle;
                _arrow_y = _sub_menu_opt_y + (option_index[_i] * _sub_menu_opt_v_sep);
                
                if(sub_menu_index[_i] == 1) {
                    _sub_menu_opt_y = _y_center - 10;
                    _arrow_y = _sub_menu_opt_y + (option_index[_i] * _sub_menu_opt_v_sep);
                }
                
                draw_set_font(fMenuLobby12);
                draw_set_halign(fa_center);
                draw_set_valign(fa_middle);
                
                if(sub_menu_index[_i] == 1) {
                    if(option_index[_i] == 0) {
                        draw_set_colour(white_col);
                        draw_text(_sub_menu_opt_x, _sub_menu_opt_y, "Continue");
                    } else {
                        draw_set_colour(_accent_col);
                        draw_text(_sub_menu_opt_x, _sub_menu_opt_y, "Continue");
                    }
                    
                    if(option_index[_i] == 1) {
                        draw_set_colour(white_col);
                        draw_text(_sub_menu_opt_x, _sub_menu_opt_y + _sub_menu_opt_v_sep, "New Game");
                    } else {
                        draw_set_colour(_accent_col);
                        draw_text(_sub_menu_opt_x, _sub_menu_opt_y + _sub_menu_opt_v_sep, "New Game");
                    }
                } else {
                    draw_set_colour(red_col);
                    draw_text(_sub_menu_header_x, _sub_menu_header_y, "Erase File?")
                
                    if(option_index[_i] == 0) {
                        draw_set_colour(white_col);
                        draw_text(_sub_menu_opt_x, _sub_menu_opt_y, "Nope");
                    } else {
                        draw_set_colour(red_col);
                        draw_text(_sub_menu_opt_x, _sub_menu_opt_y, "Nope");
                    }
                    
                    if(option_index[_i] == 1) {
                        draw_set_colour(white_col);
                        draw_text(_sub_menu_opt_x, _sub_menu_opt_y + _sub_menu_opt_v_sep, "Yeah");
                    } else {
                        draw_set_colour(red_col);
                        draw_text(_sub_menu_opt_x, _sub_menu_opt_y + _sub_menu_opt_v_sep, "Yeah");
                    }
                }
                
                draw_sprite_ext(sprAlexPauseContentArrow, 0, _arrow_x_1, _arrow_y, 1, 1, 0, -1, draw_alpha * content_alpha[_i]);
                draw_sprite_ext(sprAlexPauseContentArrow, 0, _arrow_x_2, _arrow_y, -1, 1, 0, -1, draw_alpha * content_alpha[_i]);
                break;
        }
        
        _i++;
    }
}

draw_set_alpha(overlay_alpha);
draw_set_colour(c_black);
draw_rectangle(-1, -1, room_width, room_height, false);
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
