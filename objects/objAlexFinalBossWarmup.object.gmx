<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprAlexFinalBossIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init vars

image_speed = 0.3;
image_xscale = -1;

t = 0;
floating = false;
draw_y = 0;
bouncy_orbs_y = 490;
pulse_circle_angle = 0;
pulse_circle_curve_spd = 1;
bouncy_orbs_angle = 15;
is_attacking = false;
attack_anim = 1;
aura_spd = 3;
aura_alpha = 1;
aura_base_alpha = 0.5;
aura_add_alpha = 0.2;
aura_scale = 1.5;
aura_base_scale = aura_scale;
aura_add_scale = .3;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Other checks

if(place_meeting(x, y+5, objBlock)) {
    floating = false;
} else {
    floating = true;
}

if(floating) {
    draw_y = dsin(t*2)*8;
} else {
    draw_y = 0;
}

aura_alpha = aura_base_alpha + dsin(t*aura_spd) * aura_add_alpha;
aura_scale = (aura_base_scale + dsin(t*aura_spd) * aura_add_scale) * sign(image_xscale);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Timeline

t++;

// For debug purposes, skips the majority of the warmup phase
if(global.debugMode &amp;&amp; scrButtonCheckPressed(global.skipButton) &amp;&amp; t &lt; 1370) {
    t = 1370;
    scrFinalBossTP(room_width/2, 96, sprAlexFinalBossFloat);
}

if(!instance_exists(objPlayer))
    exit;

// Create first cane
if(t == 40) {
    instance_create(x, y, objAlexFBPStartAttackCane);
    sprite_index = sprAlexFinalBossAtk;
    image_speed = 0.2;
    
    var _part = scrAlexMakeParticle(x, y, 10, sprite_index, 0, 0, 0, false, true, false);;
        _part.blend_mode = bm_add;
        _part.add_scale_x = 0.15 * sign(image_xscale);
        _part.add_scale_y = 0.15;
        _part.image_xscale = image_xscale;
}

// Teleport to the top
if(t == 70) {
    scrFinalBossTP(room_width/2, 96, sprAlexFinalBossFloat);
}

// Spin circles 1
if(t == 7*50) {
    scrFBPStartAttackCane2(x, y, room_width/2 - 250, 100, 44, 0);
    scrFBPStartAttackCane2(x, y, room_width/2 + 250, 100, 44, 0);
    
    event_user(0);
}

// Spin circles 2
if(t == 7*50 + 22) {
    scrFBPStartAttackCane2(x, y, room_width/2 - 150, 200, 44, 0);
    scrFBPStartAttackCane2(x, y, room_width/2 + 150, 200, 44, 0);
    
    event_user(0);
}

// Shower attack
if(t == 440) {
    scrFBPStartAttackCane2(x, y, room_width/2 - 200, 350, 22, 1);
    scrFBPStartAttackCane2(x, y, room_width/2, 400, 22, 1);
    scrFBPStartAttackCane2(x, y, room_width/2 + 200, 350, 22, 1);
    
    event_user(0);
}

// Targeted canes
if(t == 440 + 22) {
    scrFBPCane(x, y, true, false, 30, 1 + 22, 50, 15, -140);
    scrFBPCane(x, y, true, false, 30, 11 + 22, 50, 10, -90);
    scrFBPCane(x, y, true, false, 30, 22 + 22, 50, 15, -40);
    
    event_user(0);
}

// Squish orbs
if(t &gt;= 530-22 &amp;&amp; t &lt; 710-24 &amp;&amp; t mod 22 == 0) {
    scrFBPStartAttackCane2(x, y, room_width/2 + random_range(-300, 300), random_range(100, 150), 22, 2);
    
    with(objAlexFBPSquishOrb) {
        speed = 12;
        
        audio_stop_sound(sndAlexFBSquishOrbPulse)
        audio_play_sound(sndAlexFBSquishOrbPulse, 0, false);
    }
    
    event_user(0);
}

// Multi gustav beam
if(t == 610) {
    scrFBASMultiBeam(x + random_range(100, 200), y, 30, 128, false, 64, 90, 0, 100, 7, -200, 0);
}

// Turn squish orbs into normal orbs
if(t == 710) {
    with(objAlexFBPSquishOrb) {
        if(y &lt; 520) {
            var _orb = scrFBPOrb(x, y, 32, random_range(80, 100), 0, random_range(8, 12), 0, -0.2);
                _orb.gravity = .3;
        }
        
        instance_destroy();
    }
}


// Shower attack
if(t == 722) {
    scrFBPStartAttackCane2(x, y, room_width/2 - 200, 300, 44, 1);
    scrFBPStartAttackCane2(x, y, room_width/2 + 200, 300, 44, 1);
    
    event_user(0);
}

// Beam dodge 1 &amp; shower attack
if(t == 744) {
    scrFBPStartAttackCane2(x, y, room_width/2 - 100, 350, 22, 1);
    scrFBPStartAttackCane2(x, y, room_width/2 + 100, 350, 22, 1);

    scrFBPBeam(room_width/2 - 350, 400, 64, 50, 0, 44);
    scrFBPBeam(room_width/2 + 350, 400, 64, -50, 0, 44);
    
    event_user(0);
}
else if(t == 755) {
    scrFBPBeam(room_width/2 - 250, 470, 64, -30, 0, 56);
    scrFBPBeam(room_width/2 + 250, 470, 64, 30, 0, 56);
}
else if(t == 765) {
    scrFBPBeam(room_width/2 - 200, 460, 64, 20, 0, 68);
    scrFBPBeam(room_width/2 + 200, 460, 64, -20, 0, 68);
}
else if(t == 775) {
    scrFBPBeam(room_width/2 - 100, 440, 64, -20, 0, 80);
    scrFBPBeam(room_width/2 + 100, 440, 64, 20, 0, 80);
}



// Bouncy orbs
if(t &gt;= 900 &amp;&amp; t &lt; 960 &amp;&amp; t mod 22 == 0) {
    // Left side
    scrFBPOrbBounce(room_width/2 - 420, bouncy_orbs_y, 32, 90 - bouncy_orbs_angle, 0, 10, 0, 0, .3, 2);
    
    // Right side
    scrFBPOrbBounce(room_width/2 + 420, bouncy_orbs_y, 32, 90 + bouncy_orbs_angle, 0, 10, 0, 0, .3, 2);
    
    bouncy_orbs_y -= 80;
    bouncy_orbs_angle += 10;
}

// Beam dodge  &amp; shower attack
if(t == 932) {
    scrFBPBeam(room_width/2, 480, 64, 45, 0, 44);
    scrFBPBeam(room_width/2, 480, 64, -45, 0, 44); 
}
else if(t == 942) {
    scrFBPBeam(room_width/2 - 200, 480, 64, 20, 0, 56);
    scrFBPBeam(room_width/2 + 200, 480, 64, -20, 0, 56);
}
else if(t == 952) {
    scrFBPBeam(room_width/2 - 400, 480, 64, 30, 0, 68);
    scrFBPBeam(room_width/2 + 400, 480, 64, -30, 0, 68);
}
else if(t == 962) {
    scrFBPBeam(room_width/2 - 400, 480, 64, 45, 0, 80);
    scrFBPBeam(room_width/2 + 400, 480, 64, -45, 0, 80);
}

// split the bouncy orbs
if(t == 1060) {
    with(objAlexFBPOrbBounce) {
        if(y &lt; 520) {
            repeat(3) {
            var _orb = scrFBPOrb(x, y, 32, random_range(80, 100), 0, random_range(11, 13), 0, -.2);
                _orb.gravity = .25;
            }
            
            instance_destroy();
        }
        
        instance_destroy();
    }
}

// Spiral pulse thingy
if(t &gt;= 1070 &amp;&amp; t &lt; 1230 &amp;&amp; t mod 22 == 0) {
    scrFBPSquishOrbCircle(room_width/2, 300, pulse_circle_angle, 12, 32, pulse_circle_curve_spd, 13, 0, 0);
    pulse_circle_angle += 25;
    pulse_circle_curve_spd *= -1;
    
    with(objAlexFBPSquishOrb) {
        speed = 13;
        friction = .4;
    }
    
    audio_stop_sound(sndAlexFBSquishOrbPulse)
    audio_play_sound(sndAlexFBSquishOrbPulse, 0, false);
}

// Change the direction of the pulse orbs
if(t == 1250) {
    with(objAlexFBPSquishOrb) {
        if(x &lt; view_xview[0] || x &gt; view_xview[0] + view_wview[0] || y &lt; view_yview[0] || y &gt; 520)
            instance_destroy();
    
        direction = random(360);
        friction = 0;
        spd_incr = .04;
        dir_incr *= 0.5;
    }
}

// Zoom out cam and spawn the canes
if(t &gt; 1250 &amp;&amp; t &lt; 1400) {
    var _zoom_t = clamp(t - 1250, 0, 150);
    y = scrAlexEaseInBack(_zoom_t, 96, -120, 150)
    
    if(t mod 12 == 0) {
        scrFBPCane(random_range(450, room_width - 450), random_range(30, 200), false, true, 40, 100, 50, 0, 0, true);
        audio_stop_sound(sndAlexFBCaneThrow);
    }
}

// Prepare the landing indicator
if(t == 1500-120) {
    instance_create(objPlayer.x, 512, objAlexFinalBossSpawner);
}

// Shoot the canes and ground stomp (spawn real final boss)
if(t == 1500) {
    with(objAlexFBPCane) {
        lock_in_place = false;
    }
    
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Start attack anim

is_attacking = true;
attack_anim *= -1;

image_index = 0;
image_speed = 0.35;

if(attack_anim)
    sprite_index = sprAlexFinalBossFloatAtk1;
else
    sprite_index = sprAlexFinalBossFloatAtk2;
    
var _part = scrAlexMakeParticle(x, y, 10, sprite_index, 0, 0, 0, false, true, false);;
    _part.blend_mode = bm_add;
    _part.add_scale_x = 0.15 * sign(image_xscale);
    _part.add_scale_y = 0.15;
    _part.image_xscale = image_xscale;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Stop attack animation

if(is_attacking) {
    is_attacking = false;
    sprite_index = sprAlexFinalBossFloat;
    image_index = 0;
    image_speed = 0.3;
} else if(sprite_index == sprAlexFinalBossAtk){
    sprite_index = sprAlexFinalBossIdle;
    image_index = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Restart music

scrStopMusic();
scrPlayMusic(musFinalBoss, true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw self

draw_set_blend_mode(bm_add);
draw_sprite_ext(sprite_index, image_index, x, y + draw_y, aura_scale, abs(aura_scale), image_angle, c_fuchsia, aura_alpha);
draw_set_blend_mode(bm_normal);
draw_sprite_ext(sprite_index, image_index, x, y + draw_y, image_xscale, image_yscale, image_angle, image_blend, image_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
